> “What is a binary tree and what makes it unique to other trees?”
A: Binary Tree is the tree that has up to two child Nodes: a left Node and a right Node. 

> “What is a heuristic?”
A: Heuristic is an engineer’s best guess

> “What is another problem besides the shortest-path problem that requires the use of heuristics?”
A: The travelling salesman problem asks the following question: "Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?"

> “What is the difference between a depth-first search and a breadth-first search?”
A: 

A depth-first search is the process of traveling down a single branch in search of the desired element. If you find it, great, but if not, move upwards and repeat the process with unvisited Nodes.

A Breadth-First Search (BFS), we search an entire row of Nodes before we proceed to the next. At the root Node, this requires searching up to two Nodes. As we descend to lower levels, the number of Nodes increases.

> “Explain in your own words what an undirected, a-cyclic, unweighted graph is.”
A: Undirected: The edge connecting two Nodes is ambiguous. It neither starts nor ends at either Node, it merely connects the two like hands in a handshake; A-cyclic: A-cyclic Graphs do not form loops; performing a DFS of an A-cyclic Graph will result in a dead-end; Unweighted: Conversely, Unweighted graphs do not assign the cost of travel between Nodes.

> “What kind of graph is a binary search tree?”
A: Binary search tree is an directed, a-cyclic, and unweighted graph

> “Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.”
A:
class Node{
  constructor(val){
    this.value = val;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree{
  constructor(){
    this.root = null;  
  }
  push (val){
   var root = this.root;

   if(!root){
      this.root = new Node(val);
      return;
   }

   var currentNode = root;
   var newNode = new Node(val); 

   while(currentNode){
      if(val < currentNode.value){
          if(!currentNode.left){
             currentNode.left = newNode;
             return;
          }
          else{
             currentNode = currentNode.left;
        }
     }
     else{
         if(!currentNode.right){
            currentNode.right = newNode;
            return;
         }
         else{
            currentNode = currentNode.right;
         }
     }
  }
  }
  
  checkExist(value){
    var temp = this.root
    var status = false
    if (temp.value==value){
      status=true
  }
    while (temp.right){
      if (temp.value>value){
        temp=temp.left
    }else if (temp.value<value){
        temp=temp.right
    }else if (temp.value==value){
        status=true
        }
        }
    return status
    }    


}

> “Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance between the two nodes.”
A:
class Node{
  constructor(val){
    this.value = val;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree{
  constructor(){
    this.root = null;  
  }
  push (val){
   var root = this.root;

   if(!root){
      this.root = new Node(val);
      return;
   }

   var currentNode = root;
   var newNode = new Node(val); 

   while(currentNode){
      if(val < currentNode.value){
          if(!currentNode.left){
             currentNode.left = newNode;
             return;
          }
          else{
             currentNode = currentNode.left;
        }
     }
     else{
         if(!currentNode.right){
            currentNode.right = newNode;
            return;
         }
         else{
            currentNode = currentNode.right;
         }
     }
  }
  }
  

getLowestCommon(n1, n2, start) {
  const ancestor = start ? start : this.root;

  if (ancestor==null){
    return null;}
  if (n1 == ancestor.value && n2 == ancestor.value){
    return ancestor
  }
  if (ancestor.value > n1 && ancestor.value > n2){
    return this.getLowestCommon(n1,n2,ancestor.left);
  }
  if (ancestor.value<n1 && ancestor.value<n2) {
    return this.getLowestCommon(n1,n2,ancestor.right);
  }
  return ancestor;

}

getDepth(val, start, counter) {
  const ancestor = start ? start : this.root;
  const step = counter ? counter : 0;

  if (ancestor==null){
    return null;
  }
  if (val == ancestor.value){
    return 0;
  }
  if (val<ancestor.value){
    return this.getDepth(val,start.left,counter);
    counter+=;
  }
  if (val>ancestor.value){
    return this.getDepth(val,start.right,counter);
    counter+=;
  }

}

getDistance(n1, n2) {
  const ancestor = this.getLowestCommon(n1,n2);
  var depth1 = this.getDepth(n1,ancestor);
  var depth2 = this.getDepth(n2,ancestor);
  var distance = depth1 + depth2;

  return distance;
}

}




var bst = new BinarySearchTree();
bst.push(1);
bst.push(2);
bst.push(7);
bst.push(8);
bst.push(3);
bst.push(6);
bst.push(9);
bst.push(12);