> What is a binary tree and what makes it unique to other trees?
A: Binary Tree is the tree that has up to two child Nodes: a left Node and a right Node. 

> What is a heuristic?
A: Heuristic is an engineerâ€™s best guess

> What is another problem besides the shortest-path problem that requires the use of heuristics?
A: The travelling salesman problem asks the following question: "Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?"

> What is the difference between a depth-first search and a breadth-first search?
A: 

A depth-first search is the process of traveling down a single branch in search of the desired element. If you find it, great, but if not, move upwards and repeat the process with unvisited Nodes.

A Breadth-First Search (BFS), we search an entire row of Nodes before we proceed to the next. At the root Node, this requires searching up to two Nodes. As we descend to lower levels, the number of Nodes increases.

> Explain in your own words what an undirected, a-cyclic, unweighted graph is.
A: Undirected: The edge connecting two Nodes is ambiguous. It neither starts nor ends at either Node, it merely connects the two like hands in a handshake; A-cyclic: A-cyclic Graphs do not form loops; performing a DFS of an A-cyclic Graph will result in a dead-end; Unweighted: Conversely, Unweighted graphs do not assign the cost of travel between Nodes.

> What kind of graph is a binary search tree?
A: Binary search tree is an directed, a-cyclic, and unweighted graph

> Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.
A:
class BinarySearchTree{
  function Node(val){
    this.value = val;
    this.left = null;
    this.right = null;
}
  function BinarySearchTree(){
    this.root = null;
}

  BinarySearchTree.prototype.push = function(val){
   var root = this.root;

   if(!root){
      this.root = new Node(val);
      return;
   }

   var currentNode = root;
   var newNode = new Node(val); 

   while(currentNode){
      if(val < currentNode.value){
          if(!currentNode.left){
             currentNode.left = newNode;
             break;
          }
          else{
             currentNode = currentNode.left;
        }
     }
     else{
         if(!currentNode.right){
            currentNode.right = newNode;
            break;
         }
         else{
            currentNode = currentNode.right;
         }
     }
  }

}

  function checkExist(bst,value){
    var temp = bst.root
    var status = false
    if (temp.value==value){
      status=true
  }
    while (temp.right){
      if (temp.value>value){
        temp.value=temp.left
    }else if (temp.value<value){
        temp.value=temp.right
    }else if (temp.value==value){
        status=true
        }
        }
    return status
    }    
    }

var bst = new BinarySearchTree();
bst.push(3);
bst.push(2);
bst.push(4);
bst.push(1);
bst.push(5);

> Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance between the two nodes.
A:
class BinarySearchTree{
  function Node(val){
    this.value = val;
    this.left = null;
    this.right = null;
}
  function BinarySearchTree(){
    this.root = null;
}

  BinarySearchTree.prototype.push = function(val){
   var root = this.root;

   if(!root){
      this.root = new Node(val);
      return;
   }

   var currentNode = root;
   var newNode = new Node(val); 

   while(currentNode){
      if(val < currentNode.value){
          if(!currentNode.left){
             currentNode.left = newNode;
             break;
          }
          else{
             currentNode = currentNode.left;
        }
     }
     else{
         if(!currentNode.right){
            currentNode.right = newNode;
            break;
         }
         else{
            currentNode = currentNode.right;
         }
     }
  }

}

  function findPath(n1, n2){
  var distance=0
  if (n1 === n2){
    return distance
  }
  
  while (n1.left!=null || n1.right!=null){
    if (findPath(n1.left,n2)<findPath(n1,n2)){
      distance+=findPath(n1.left,n2)
      n1=n1.left
    }else if (findPath(n1.right,n2)<findPath(n1.right,n2){
      distance+=findPath(n1.right,n2)
      n1=n1.right
    }
  }
  return distance
}  
    }

var bst = new BinarySearchTree();
bst.push(3);
bst.push(2);
bst.push(4);
bst.push(1);
bst.push(5);

